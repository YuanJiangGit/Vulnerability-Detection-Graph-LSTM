# -*- coding: utf-8 -*-
# @Time    : 3/10/22 8:58 PM
# @Author  : YuanJiang
# @Site    : 
# @File    : SemanticGraphUtils.py
# @Software: PyCharm

from general_op import getFuncPDGById, getFuncASTById

def _gather_node_attributes(node, key):
    features = [node[key]]
    for child in node['children']:
        features.extend(_gather_node_attributes(child, key))
    return features

def sing_tree2dict(single_tree, dict):
    '''
    将迭代的single_tree转化为dict形式
    :param single_tree:
    :param dict:
    :return:
    '''
    location = single_tree['node_location']
    if location != None:
        node_location_lst = [x for x in location.split(':')]
        location_str = node_location_lst[0] + '_' + node_location_lst[1] + '_' + str(int(node_location_lst[3]) - int(node_location_lst[2]) + 1)

        dict[location_str] = {"features": single_tree["features"], "node_tokens": single_tree["node_tokens"], "children": single_tree["children"]}
    for child in single_tree['children']:
        sing_tree2dict(child, dict)


def slice_semantic_graph(_list, key):
    '''
    obtain slice graph (_list: slice nodes, key: slice test id)
    :param _list: slice nodes
    :param key:  slice test id
    :return:
    '''
    # aim to obtain the following three data
    new_graph_features = []
    adjacency_list = []
    features = []

    functionset = set()
    for node in _list:
        # obtain the functionID in the slice code gadget
        functionID = node['functionId']
        functionset.add(functionID)
        # obtain feature of each statement in the code gadget
        features.append(node['type']) # use "type" of node rather than "code" of node since it is not a leaf node\

    # obtain id ('name') of nodes in pdg igraph
    listname = []
    for listnode in _list:
        listname.append(listnode['name'])

    # obtain callee relationship in the code gadget (_list)
    for m in range(len(_list)):
        if m == len(_list) - 1:
            continue
        elif (_list[m]['functionId'] != _list[m + 1]['functionId']):
            # call_functionID = _list[m+1]['functionId']
            d = dict()
            d['sid'] = listname.index(_list[m]['name'])
            d['eid'] = listname.index(_list[m + 1]['name'])
            adjacency_list.append([d['sid'], d['eid']])
        else:
            continue

    # obtain pdg and ast of programs
    pdg_set = []
    for functionID in functionset:
        pdg = getFuncPDGById(key, functionID)
        pdg_set.append(pdg)

    # obtain the adjacency_list from pdg
    for pdg in pdg_set:
        for edge in pdg.es:
            if pdg.vs[edge.source]['name'] in listname and pdg.vs[edge.target]['name'] in listname \
                    and pdg.vs[edge.source]['location'] != None and pdg.vs[edge.target]['location'] != None:
                #  pdg.vs[edge.source]['name'], pdg.vs[edge.target]['name']
                d = dict()
                d['sid'] = listname.index(pdg.vs[edge.source]['name']) # the index of source node in the node list
                d['eid'] = listname.index(pdg.vs[edge.target]['name'])
                adjacency_list.append([d['sid'],d['eid']])


    # obtain the features and adjacency_list of sub-tree AST of each statement
    ast_local_info = {} # FORM: key (location) : value (syntax nodes in the AST)
    node_id_count = len(_list)
    for index, node in enumerate(_list):
        # if the type of a statement is Function, the subtree of the statement is the entire function tree
        if node['type'] == 'Function':
            continue
        # obtain the functionID in the slice code gadget
        functionID = node['functionId']
        # obtain ast of the function (functionID)
        if functionID not in ast_local_info.keys():
            ast = getFuncASTById(key, functionID)
            if ast == None: return None # ast not exists
            nodes_locat_dict = {}
            # convert ast to dict, key is node's location and value is the node itself
            sing_tree2dict(ast, nodes_locat_dict)
            ast_local_info[functionID] = nodes_locat_dict
        else:
            nodes_locat_dict = ast_local_info[functionID]

        # 4:1:15:17
        node_location = node['location']
        if node_location == None: continue
        # find the corresponding sub-ast tree of node
        node_ast_info = node2ast(node_location, nodes_locat_dict)

        # if has no corresponding tree, should continue (jiangyuan, 3-10)
        if node_ast_info == None: continue
        # relabel index for sub-tree, (sub-tree root node id is node_id_count)
        _label_node_index(node_ast_info, node_id_count)

        node_ast_feature = _gather_node_attributes(node_ast_info, 'features')  # 类似于 ['binary_expression', 'subscript_expression', 'mul_save', '[', 'len', ']', '!=', '0']
        # print(node['code'])
        # print(node_ast_feature)

        # pdg node --> sub-ast tree root node
        adjacency_list.append([index, node_id_count])
        # sub-ast tree adjacency list
        adjacency_list.extend(_gather_adjacency_list(node_ast_info))  #
        new_graph_features.extend(node_ast_feature)

        node_id_count += len(node_ast_feature)
    return {'tree-features': features, 'graph_adjacency_list': adjacency_list, 'graph_features':new_graph_features}


def _label_node_index(node, n=0):
    '''
    给node加上id
    :param node:
    :param n:
    :return:
    '''
    node['index'] = n
    for child in node['children']:
        n = _label_node_index(child, n + 1)
    return n


def _gather_adjacency_list(node):
    adjacency_list = []
    for child in node['children']:
        adjacency_list.append([child['index'], node['index']])  # 这里是孩子节点指向父节点
        adjacency_list.extend(_gather_adjacency_list(child))
    return adjacency_list


def node2ast(query_node_location, nodes_locat_dict):
    '''
    返回查询的PDG节点对应的语法子树
    :param query_node_location: e.g., # 4:1:15:17 (第4行，4行的第1个偏移位置，相对于整体程序的第15个偏移到第17个偏移)
    :param nodes_locat_dict:
    :return:
    '''

    # 4:1:15:17 改成 4:1:3 （）
    node_location_lst = [x for x in query_node_location.split(':')]
    query_node_location_str = node_location_lst[0] + '_' + node_location_lst[1] + '_' + str(int(node_location_lst[3]) - int(node_location_lst[2]) + 1)
    # 如果query_location在字典的key中，直接返回key对应的AST
    if query_node_location_str in nodes_locat_dict:
        return nodes_locat_dict[query_node_location_str]
    #
    q_line, q_start_point, q_len = [int(x) for x in query_node_location_str.split('_')]
    node_locat_lst = [(key, value) for key, value in nodes_locat_dict.items() if int(key.split('_')[0])==q_line]
    node_locat_lst.reverse() # 选择刚好小于query_node的AST，所以应该从line行的右往左比较
    if len(node_locat_lst) == 0: # not has the corresponding AST
        return None
    allow_loss_len=0
    if 0<q_len<20:
        allow_loss_len = 2
    elif q_len>=20 and q_len<40:
        allow_loss_len = 3
    elif q_len>=40 and q_len < 50:
        allow_loss_len = 5
    elif q_len>=50 and q_len<70:
        allow_loss_len = 7
    elif q_len >= 70 and q_len < 90:
        allow_loss_len = 8
    elif q_len >= 90 and q_len < 120:
        allow_loss_len = 9
    elif q_len >= 120:
        allow_loss_len = 10

    for key, value in node_locat_lst:
        line, start_point, len =[int(x) for x in key.split('_')]
        if q_start_point>=start_point and q_len<=len+allow_loss_len: # 允许有一个单位的误差，因为statement的分号的缘故
            return value

    for key, value in node_locat_lst:
        line, start_point, len =[int(x) for x in key.split('_')]
        if q_start_point+2>=start_point and q_len<=len+allow_loss_len: # 允许有一个单位的误差，因为statement的分号的缘故
            return value

    # 如果实在解析不对，返回一个当前行的AST
    return node_locat_lst[-1][1]